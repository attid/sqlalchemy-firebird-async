from sqlalchemy_firebird.base import FBCompiler
from sqlalchemy_firebird.base import FBTypeCompiler
from sqlalchemy_firebird.base import FBDDLCompiler
from sqlalchemy.sql import elements
from sqlalchemy.sql import expression
from sqlalchemy.sql import operators
from sqlalchemy.sql.compiler import OPERATORS

class PatchedFBDDLCompiler(FBDDLCompiler):
    def visit_unique_constraint(self, constraint, **kw):
        # Firebird can be picky about quoted constraint names with spaces in some contexts
        # but SQLAlchemy testing uses them.
        return super().visit_unique_constraint(constraint, **kw)

class PatchedFBTypeCompiler(FBTypeCompiler):
    def _render_string_type(self, type_, name=None, length_override=None, **kwargs):
        if name is None and isinstance(type_, str):
            name = type_
            type_ = None

        if length_override is None and "length" in kwargs:
            length_override = kwargs.pop("length")

        collation = kwargs.pop("collation", None)

        if type_ is None:
            text = name
            if length_override:
                text += f"({length_override})"
            if collation:
                text += f" COLLATE {collation}"
            return text

        # Fix for TypeError: unsupported operand type(s) for +: 'int' and 'str'
        if not isinstance(name, str):
            # Attempt to restore type name from the type object itself
            if hasattr(type_, "__visit_name__"):
                name = type_.__visit_name__.upper()
            else:
                name = "VARCHAR"
        return super()._render_string_type(type_, name, length_override)

    def visit_VARCHAR(self, type_, **kw):
        return self._render_string_type(type_, "VARCHAR", length_override=type_.length)

    def visit_CHAR(self, type_, **kw):
        return self._render_string_type(type_, "CHAR", length_override=type_.length)

    def visit_NVARCHAR(self, type_, **kw):
        return self._render_string_type(type_, "NVARCHAR", length_override=type_.length)

    def visit_NCHAR(self, type_, **kw):
        return self._render_string_type(type_, "NCHAR", length_override=type_.length)

    def visit_DOUBLE(self, type_, **kw):
        return "DOUBLE PRECISION"

    def visit_DOUBLE_PRECISION(self, type_, **kw):
        return "DOUBLE PRECISION"

    def visit_FLOAT(self, type_, **kw):
        return "DOUBLE PRECISION"

    def visit_TIMESTAMP(self, type_, **kw):
        return "TIMESTAMP"

    def visit_TIME(self, type_, **kw):
        return "TIME"

    def visit_datetime(self, type_, **kw):
        return "TIMESTAMP"


import re

class PatchedFBCompiler(FBCompiler):
    def visit_bindparam(self, bindparam, within_columns_clause=False, **kwargs):
        if within_columns_clause and bindparam.value is not None:
             # Check for NullType FIRST to avoid CompileError
             from sqlalchemy.types import NullType
             if isinstance(bindparam.type, NullType):
                 return super().visit_bindparam(bindparam, within_columns_clause=within_columns_clause, **kwargs)

             # Firebird needs CAST for parameters in SELECT list
             # SELECT ? -> SELECT CAST(? AS <type>)
             db_type = self.dialect.type_compiler.process(bindparam.type)
             if db_type and "NULL" not in db_type.upper():
                  # Firebird CAST(.. AS TIMESTAMP(6)) is not valid, use CAST(.. AS TIMESTAMP)
                  if "TIMESTAMP" in db_type and "(6)" in db_type:
                       db_type = db_type.replace("(6)", "")
                  elif "TIME" in db_type and "(6)" in db_type:
                       db_type = db_type.replace("(6)", "")
                  
                  return f"CAST({super().visit_bindparam(bindparam, within_columns_clause=within_columns_clause, **kwargs)} AS {db_type})"
        
        ret = super().visit_bindparam(bindparam, within_columns_clause=within_columns_clause, **kwargs)
        
        # If we are NOT in the columns clause (e.g. WHERE, INSERT values), 
        # modify the CAST(...) wrapper generated by the parent compiler.
        # Firebird infers strict types from context (e.g. VARCHAR(2) col -> VARCHAR(2) param),
        # which causes truncation for LIKE patterns longer than the column.
        # We widen the CAST to VARCHAR(2000) to allow longer patterns.
        # We avoid max length (32765) to prevent "Implementation limit exceeded" errors.
        if not within_columns_clause and "CAST" in ret and "VARCHAR" in ret:
             ret = re.sub(r'(VARCHAR|CHAR|NVARCHAR|NCHAR)\(\d+\)', r'\1(2000)', ret)
        
        return ret

    def order_by_clause(self, select, **kw):
        if isinstance(select, expression.CompoundSelect):
            return self._compound_order_by_clause(select, **kw)
        return super().order_by_clause(select, **kw)

    def _compound_order_by_clause(self, select, **kw):
        if not select._order_by_clauses:
            return ""

        pos_by_name = {}
        for idx, col in enumerate(select.selected_columns, 1):
            for key in (getattr(col, "key", None), getattr(col, "name", None)):
                if key and key not in pos_by_name:
                    pos_by_name[key] = idx

        clauses = []
        for clause in select._order_by_clauses:
            elem = clause
            direction = None

            if isinstance(elem, elements.UnaryExpression) and elem.modifier in (
                operators.asc_op,
                operators.desc_op,
            ):
                direction = elem.modifier
                elem = elem.element

            if isinstance(elem, elements._label_reference):
                elem = elem.element
                if isinstance(elem, elements.UnaryExpression) and elem.modifier in (
                    operators.asc_op,
                    operators.desc_op,
                ):
                    direction = elem.modifier
                    elem = elem.element

            if isinstance(elem, elements._textual_label_reference):
                key = elem.element
            else:
                key = getattr(elem, "key", None) or getattr(elem, "name", None)

            if key in pos_by_name:
                position = expression.literal_column(str(pos_by_name[key]))
                if direction is operators.desc_op:
                    position = position.desc()
                elif direction is operators.asc_op:
                    position = position.asc()
                clauses.append(position)
                continue

            clauses.append(clause)

        order_by = self._generate_delimited_list(
            clauses, OPERATORS[operators.comma_op], **kw
        )
        if order_by:
            return " ORDER BY " + order_by
        return ""
